import DataSet from '@antv/data-set';
import { isArray, isFunction, isNumber, isString } from '@antv/util';
import { log, LEVEL, getContainerSize } from '../../utils';
/**
 * 用 DataSet 转换词云图数据
 * @param params
 */
export function transform(params) {
    var options = params.options;
    var data = options.data, imageMask = options.imageMask, wordField = options.wordField, weightField = options.weightField, wordStyle = options.wordStyle, timeInterval = options.timeInterval;
    if (!data || !data.length) {
        return [];
    }
    var fontFamily = wordStyle.fontFamily, fontWeight = wordStyle.fontWeight, padding = wordStyle.padding;
    var dv = new DataSet.View().source(data);
    var range = dv.range(weightField);
    dv.transform({
        type: 'tag-cloud',
        fields: [wordField, weightField],
        imageMask: imageMask,
        font: fontFamily,
        fontSize: getFontSize(options, range),
        fontWeight: fontWeight,
        // 图表宽高减去 padding 之后的宽高
        size: getSize(params),
        padding: padding,
        timeInterval: timeInterval,
        rotate: getRotate(options),
    });
    return dv.rows;
}
/**
 * 获取最终的实际绘图尺寸：[width, height]
 * @param chart
 */
function getSize(params) {
    var chart = params.chart, options = params.options;
    var _a = options.autoFit, autoFit = _a === void 0 ? true : _a;
    var width = chart.width, height = chart.height;
    // 由于词云图每个词语的坐标都是先通过 DataSet 根据图表宽高计算出来的，
    // 也就是说，如果一开始提供给 DataSet 的宽高信息和最终显示的宽高不相同，
    // 那么就会出现布局错乱的情况，所以这里处理的目的就是让一开始提供给 DataSet 的
    // 宽高信息与最终显示的宽高信息相同，避免显示错乱。
    if (autoFit) {
        var containerSize = getContainerSize(chart.ele);
        width = containerSize.width || 0;
        height = containerSize.height || 0;
    }
    var _b = resolvePadding(chart), top = _b[0], right = _b[1], bottom = _b[2], left = _b[3];
    var result = [width - (left + right), height - (top + bottom)];
    return result;
}
/**
 * 根据图表的 padding 和 appendPadding 计算出图表的最终 padding
 * @param chart
 */
function resolvePadding(chart) {
    var padding = normalPadding(chart.padding);
    var appendPadding = normalPadding(chart.appendPadding);
    var top = padding[0] + appendPadding[0];
    var right = padding[1] + appendPadding[1];
    var bottom = padding[2] + appendPadding[2];
    var left = padding[3] + appendPadding[3];
    return [top, right, bottom, left];
}
/**
 * 把 padding 转换成统一的数组写法
 * @param padding
 */
function normalPadding(padding) {
    if (isNumber(padding)) {
        return [padding, padding, padding, padding];
    }
    if (isArray(padding)) {
        var length_1 = padding.length;
        if (length_1 === 1) {
            return [padding[0], padding[0], padding[0], padding[0]];
        }
        if (length_1 === 2) {
            return [padding[0], padding[1], padding[0], padding[1]];
        }
        if (length_1 === 3) {
            return [padding[0], padding[1], padding[2], padding[1]];
        }
        if (length_1 === 4) {
            return padding;
        }
    }
    return [0, 0, 0, 0];
}
/**
 * 处理 imageMask 可能为 url 字符串的情况
 * @param img
 * @param callback
 */
export function processImageMask(img, callback) {
    if (img instanceof HTMLImageElement) {
        callback(img);
        return;
    }
    if (isString(img)) {
        var image_1 = new Image();
        image_1.crossOrigin = 'anonymous';
        image_1.src = img;
        image_1.onload = function () {
            callback(image_1);
        };
        image_1.onerror = function () {
            log(LEVEL.ERROR, false, 'image %s load failed !!!', img);
            callback();
        };
        return;
    }
    log(LEVEL.WARN, img === undefined, 'the type of imageMask option must be String or HTMLImageElement.');
    callback();
}
/**
 * 把用户提供的 fontSize 值转换成符合 DataSet 要求的值
 * @param options
 * @param range
 */
function getFontSize(options, range) {
    var fontSize = options.wordStyle.fontSize;
    var min = range[0], max = range[1];
    if (isFunction(fontSize)) {
        return fontSize;
    }
    if (isArray(fontSize)) {
        var fMin_1 = fontSize[0], fMax_1 = fontSize[1];
        return function fontSize(_a) {
            var value = _a.value;
            return ((fMax_1 - fMin_1) / (max - min)) * (value - min) + fMin_1;
        };
    }
    return fontSize;
}
/**
 * 把用户提供的关于旋转角度的字段值转换成符合 DataSet 要求的值
 * @param options
 */
function getRotate(options) {
    var _a = resolveRotate(options), rotateRatio = _a.rotateRatio, rotation = _a.rotation, rotationSteps = _a.rotationSteps;
    var min = rotation[0];
    var max = rotation[1];
    // 等于 1 时不旋转，所以把每份大小设为 0
    var perSize = rotationSteps === 1 ? 0 : (max - min) / (rotationSteps - 1);
    return function rotate() {
        return Math.ceil(Math.random() * (rotationSteps - 1)) * perSize * isHappen(rotateRatio);
    };
}
/**
 * 根据传入的数字推断是否发生，返回 1 表示发生，0 表示未发生
 * @param n 概率值，可以是从 0 到 1 的数字
 */
function isHappen(n) {
    return Math.random() < n ? 1 : 0;
}
/**
 * 确保值在要求范围内
 * @param options
 */
function resolveRotate(options) {
    var _a = options.wordStyle, rotation = _a.rotation, rotationSteps = _a.rotationSteps, rotateRatio = _a.rotateRatio;
    if (!isArray(rotation)) {
        log(LEVEL.WARN, false, 'the rotation option must be an Array in wordStyle option.');
        rotation = [0, 90];
    }
    if (rotationSteps === 0) {
        log(LEVEL.WARN, false, 'the rotationSteps option must be greater than or equal to 1.');
        rotationSteps = 1;
    }
    if (rotateRatio < 0) {
        log(LEVEL.WARN, false, 'the rotateRatio option must be greater than or equal to 0 and less than or equal to 1.');
        rotateRatio = 0;
    }
    if (rotateRatio > 1) {
        log(LEVEL.WARN, false, 'the rotateRatio option must be greater than or equal to 0 and less than or equal to 1.');
        rotateRatio = 1;
    }
    return {
        rotation: rotation,
        rotationSteps: rotationSteps,
        rotateRatio: rotateRatio,
    };
}
//# sourceMappingURL=utils.js.map