"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util_1 = require("@antv/util");
var base_1 = tslib_1.__importDefault(require("./base"));
/**
 * 柱状图 label
 */
var IntervalLabel = /** @class */ (function (_super) {
    tslib_1.__extends(IntervalLabel, _super);
    function IntervalLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * 获取 interval label 的方向，取决于 value 的值是正还是负
     * @param labelCfg
     */
    IntervalLabel.prototype.getLabelValueDir = function (mappingData) {
        // points 中的 x/y 和 transpose 无关
        var dim = 'y';
        var points = mappingData.points;
        return points[0][dim] < points[2][dim] ? 1 : -1;
    };
    /**
     * 重载：根据 interval 值的正负来调整 label 偏移量
     * @param labelCfg
     * @param index
     * @param total
     */
    IntervalLabel.prototype.getLabelOffset = function (labelCfg, index, total) {
        var point = _super.prototype.getLabelOffset.call(this, labelCfg, index, total);
        var transposed = this.getCoordinate().isTransposed;
        var dim = transposed ? 'x' : 'y';
        var dir = this.getLabelValueDir(labelCfg.mappingData);
        point[dim] *= dir;
        return point;
    };
    /**
     * 重载：定制 interval label 的默认主题配置
     * @param labelCfg
     */
    IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {
        var geometry = this.geometry;
        var defaultLabelCfg = this.getDefaultLabelCfg();
        var theme = geometry.theme;
        // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0
        return util_1.deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? { offset: 0 } : {}, labelCfg);
    };
    IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {
        var coordinate = this.getCoordinate();
        var transposed = coordinate.isTransposed;
        var shapePoints = mappingData.points;
        var point0 = coordinate.convert(shapePoints[0]);
        var point1 = coordinate.convert(shapePoints[2]);
        var flag = transposed ? -1 : 1;
        var width = ((point0.x - point1.x) / 2) * flag;
        var height = ((point0.y - point1.y) / 2) * flag;
        var dir = this.getLabelValueDir(mappingData);
        switch (position) {
            case 'right':
                if (!transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');
                break;
            case 'left':
                if (transposed) {
                    labelPointCfg.x -= width * 2;
                }
                else {
                    labelPointCfg.x += width;
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');
                break;
            case 'bottom':
                if (transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y -= height;
                }
                else {
                    labelPointCfg.y += height * 2;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = util_1.get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');
                break;
            case 'middle':
                if (transposed) {
                    labelPointCfg.x -= width;
                }
                else {
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = util_1.get(labelPointCfg, 'textBaseline', 'middle');
                break;
            case 'top':
                if (transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = util_1.get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');
                break;
            default:
                break;
        }
    };
    return IntervalLabel;
}(base_1.default));
exports.default = IntervalLabel;
//# sourceMappingURL=interval.js.map